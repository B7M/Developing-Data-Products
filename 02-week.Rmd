# Second week

During this module, we'll learn how to create R Markdown files and embed R code in an Rmd. We'll also explore Leaflet and use it to create interactive annotated maps.
Learning Objectives
Create an R Markdown file
Employ R code in an Rmd
Create a map using Leaflet
Use Leaflet to add legends, markers, circles, and rectangles to your map

## R Markdown


### R Markdown 1.1
This lecture will discuss how to create reproducible presentations using R Markdown. In previous versions of the class, we covered several ways to do this, including R Studio Presenter and Slidify. However, in this latest version, we will focus solely on Markdown. R Markdown is already covered in the data science specialization's class on reproducible research, but we will still touch on why it's important to create reproducible documents and presentations.
R Markdown is a feature of R Studio that enables the creation of documents, such as HTML documents, directly from within R. What makes it particularly useful is that it embeds code, results, and plots from the analysis into the document, making it a self-contained and reproducible unit. In contrast, traditional workflows typically involve separate documents and code files, with manual copying and pasting or saving and importing files, which can create issues with version control and reproducibility. R Markdown provides a consistent structure for generating presentations and documents, making it a better option for those concerned with reproducibility. For instance, in a corporate setting where a report needs to be presented routinely, having a script that generates the presentation with the latest data in a version-controlled way would be more efficient and reliable than manually copying and pasting each time. R Markdown can be useful for creating recurring or automated presentations, but it has many other uses as well. One important benefit is its ability to improve the reproducibility of documents. In the academic community, there have been many instances where papers have been published and subsequent groups have tried to reproduce the results, only to find that it's often not possible. This can lead to disputes and uncertainty over who is right. However, embedding the code in a document using R Markdown greatly improves its reproducibility. While there may still be some external factors that impact the results, overall it goes a long way towards creating more reliable and reproducible documents. Let's hope that you've already covered some of these concepts in your reproducible research class as part of the data science specialization. However, if you're taking this class in Ovo, we'll guide you through a few examples with a focus on creating reproducible presentations. This class emphasizes the creation of products, and your presentation serves as your product pitch. Therefore, we want your pitch to be in one of these reproducible formats. So, let's move on to some examples.


### R Markdown 1.2
Alright, we have reached this slide in our presentation. From here on, we will be demonstrating the code to create reproducible presentations using R Markdown. So, instead of going through the slides one by one, we will switch to R Studio and show you how to do this practically. 
It's important to highlight that we follow the same approach we're teaching, and we have actually created the slides for this class using R Markdown. However, for the purpose of this demonstration, we will create a new presentation. To do so, we need to go to File > New File > R Markdown, which can also be accessed through Alt+F > F > R Markdown, that is M. Once there, we will see a "Presentation Title" field, where we can name our presentation "My Fancy Presentation" and add our name as the author. There are various output options available, but for now, let's stick with the ioslides format as the default option. However, if you prefer a PDF output, it requires the installation of MiKTeX on Windows, MacTeX on OS X, or TeX Live on Linux. These installations are easy to set up but can be quite large. We'll cover this in more detail later in the lecture. The ioslides format was created based on one of the Google presentations. Okay, so the file name for the R Markdown commands is currently "Untitled1". Let's compile it once to see what it looks like. You can either click on "Knit the current document" or use the shortcut Ctrl+Shift+K. I'm going to name my file "briansSlides" instead of the default name. And there you go, it's running and the output is "My Fancy Presentation". Your homework is to create a new presentation using the template, compile it once, and then we'll move on to adding content. 


### R Markdown 1.3
Let's take a look at the preamble section surrounded by three dashes. You can change the title, author, and date from here. You can also change the format if you want it to be a different type of output, such as "slidy" instead of "ioslides". The knitr options specify that code included in the document won't be echoed by default. To create a new slide, add two pound signs and then the slide title, such as "My New Slide". Let's knit the document to see the changes. Alright, now we have a slide with some content and a slide without a title. As you can see, we used two pound signs to create a slide with a title, and three asterisks to create a slide without a title. Let's knit it again to see how it looks. Let's take a look at our new slides with some content, and the slide without a title. Now, let's add a subheading. We'll use two pound signs for "My title", three pound signs for a top-level subheading, and four pound signs for a second-level subheading. Let's knit it to see how it looks. Remember, you can also use Ctrl+Shift+K to knit the document. Now, let's add some more content by creating a list with two bullet points. Okay, let's take a look at the YAML preamble first. The YAML section is surrounded by three dashes, and it contains information such as the title, author, date, and output format. You can easily change these options at this point.

To create a new slide, simply add two pound signs and the title of the slide. For example, "## My New Slide". To create a slide without a title, use three asterisks like this: "***".

To add subheadings, use three or four pound signs depending on the level of the subheading. For example, "### Top Level Subheading" and "#### Second Level Subheading".

To create a bulleted list, use two dashes to start each item. For an ordered list, use numbers followed by a period. For example, "1. Item a" and "2. Item b".

Once you have added your content, you can knit the document to see the final output. You can use the shortcut Ctrl+Shift+K to knit the document.

Now, it's time to create some slides with your own content. Add titles, headings, subheadings, bulleted and ordered lists to your slides. 


### R Markdown 1.4
Let's take a look at some formatting options. For instance, if I write plain text, *italicized text*, and **bold text**, you can see that it's automatically syntax highlighted. Additionally, I can add some code, such as `1:10`, by using single right-facing quotation marks. Remember that to use italics, you need to have one asterisk next to the leading character, and to use bold, you need two asterisks next to the leading character. It's important to note that the asterisks must be next to the leading character for it to work correctly. Let's run it now and see the results.

### R Markdown 1.5
Alright, let's take a look at some formatting options. If I just type in plain text, *italicized text*, and **bold text**, notice how the formatting automatically adjusts. Also, here's an example of some code: `1:10`. To indicate that it's R code, we surround it with single quotation marks and specify the language as "r" in the curly braces at the beginning. You'll notice that the code is highlighted differently than the rest of the text. Let's add a bit more code: `head(mtcars)`. This will show the first few rows of the dataset "mtcars". You can actually run the code in RStudio and see the output down below. However, to generate the entire document, hit Ctrl+Shift+K and there you have it - a new slide. Okay, let's experiment with the options available. I've deleted some of the slides, so we can focus on this simple code example. I noticed that I don't like the comment characters in front of the output, so I'll use the `comment` option to remove them. Let's try it out with `comment = ""`. Great! Now, let's play around with some more options. I deleted some slides so we can focus on this simple code example. Initially, I didn't like the comment characters in front of the output, so I tried using the "comment" option to get rid of them. I set it to nothing, and it looks better now. 

By default, the "echo" option was set to false, which means that it didn't show the code that generated the output, just the output itself. When typing in Knitr options, you can see a list of available options once you add a comment and start typing. 

If I set "echo" to true and regenerate the presentation, you'll see that it now shows both the output and the code that generated it. The default option is "echo=true", which means that you don't have to specify it explicitly. I could have also just removed the Knitr options at the beginning and it would have behaved the same way, since "echo=true" is the default.

Let's try this instead: 

Now, let's experiment with some Knitr options. By default, the `echo` option is set to `false`, which means that it doesn't show the code used to generate the output. If we want to see the code, we can set `echo` to `true`. For example, if we use `echo = TRUE`, we will see both the code and the output. 

If we want to show the code but not evaluate it, we can set `eval` to `FALSE`. On the other hand, if we want to hide the code and only show the output, we can set `echo` to `FALSE`. 

There are many other options available in Knitr that can be used to customize the output of our R code. To change the comment character, for example, we can use `comment = ""`. 

Now, it's your turn to try it out. Create a slide with some R code and experiment with different Knitr options to see how they affect the output. In the next section, we'll cover how to include figures in our presentations. 


### R Markdown 1.6
Alright, let me show you a plot that I created using the code: `plot(empty_cars$weight, empty_cars$mpg, xlab="Weight", ylab="MPG")`. Here's what it looks like: 

[My Awesome Figure]

As you can see, I also used some of the figure options in knitr, such as `echo = FALSE` to not show the code, `fig.align = "center"` to center the figure, and `fig.cap = "My AWESOME figure"` to add a caption. There are many other figure options that you can explore in knitr.  Let me summarize what you just explained. To show a plot without the code, you can set the "echo" option to FALSE when calling the plot function. You can also use other figure options such as "fig.align" and "fig.cap" to control the alignment and add a caption to the figure. To publish your slides, you can use R markdown to create an HTML file, which can be opened in a browser. You can also use R pubs, Drop Box, or GitHub to publish it online. GitHub is one of the most popular ways to share code and collaborate with others. Let me demonstrate how to publish your slides using different methods. First, let's review some of the options for publishing your slides in R Markdown. When you knit your R Markdown document using `knit HTML`, it creates an HTML file in your directory. For example, if your R Markdown file is named `briansSlides.Rmd`, it creates a `briansSlides.html` file. You can open this file in a web browser to view your presentation.

You can also publish your slides online using several platforms. One option is R Pubs, where you can share your presentation with others. Another option is to put it in a Dropbox public folder, or you can publish it on GitHub. 

To publish your slides on GitHub, you can create a repository and push your R Markdown and HTML files to it. For example, Sean Cross' Developing Data Products course has a page for slides in his GitHub repository. You can see that it is just an R Markdown file and the associated HTML file pushed up into GitHub.

When you click on the R Markdown file in GitHub, it does a lot of the formatting for you. It recognizes that it is an R Markdown document and does a lot of formatting ahead for you. You can see what the bullets and various points are going to look like. When you click on the HTML file, it shows you the raw HTML, not the rendered presentation. Okay, let's discuss how to render the HTML file. There are different ways to do it, such as using a Chrome or Firefox add-on, but Sean published his slides through GitHub Pages. He created a branch called "gh-pages," which is required for GitHub Pages to work. Usually, a Node.js file is also needed in the root directory, but it seems Sean didn't have to use it. To access the rendered HTML, you just need to slightly modify the URL by replacing "github.com/seankross" with "seankross.github.io" and removing "slides/blob/gh-pages" from the path. Then, you just need to navigate to the subdirectories where the HTML file is located. For example, in Sean's GitHub repository, the file is in "slides/Developing Data Products/R Markdown/R Markdown.html." These slides are now hosted on GitHub, which is a convenient option for data scientists who are already using GitHub to manage their projects. Personally, I push my course materials to a public GitHub repository and my private research to a private repository. Okay, now it's time to create a figure in your presentation and experiment with the different figure options available. I also want you to try publishing your presentation to GitHub. If you encounter any issues, read up on GitHub pages or try publishing to Rpubs instead. You can easily publish to Rpubs by clicking on the publish button in RStudio. Once you've published your presentation, make sure to verify that the HTML file gets created in your directory. You can also host it on your computer and view it offline, which is useful if you're working in an environment without internet access.

Hosting your presentation on GitHub can be technically challenging, but it's worth trying since it's a convenient way to publicly host your repositories. Once you've developed your project, you'll create a pitch in R Markdown and hopefully host it on GitHub or another platform. This way, we can all view your project and appreciate how awesome it is. 

That's all the information about R Markdown we need for this class. Thank you for listening, and we'll see you in the next lesson.

## Three Ways to Share R Markdown Products
We recommend the following websites for sharing the HTML files that you produce from R Markdown documents. If you've taken The Data Scientist's Toolbox then you should be familiar with [GitHub Pages](https://pages.github.com). If you're familiar with Git and you haven't used it before their documentation for creating a site is very straightforward. If you're not familiar with Git and you're using RStudio you should take advantage of [RPubs](https://rpubs.com), which is perhaps the easiest way to share an HTML document from RStudio. You can find simple instructions for using RPubs [here](https://rpubs.com/about/getting-started). If you're looking for a site that will host any HTML file for free, including HTML files that are generated by R Markdown, you should check out [NeoCities](https://neocities.org). You'll need to provide links to HTML files you've created with R Makrdown in upcoming peer assessments, so make sure to familiarize yourself with one of these sites.

## Leaflet

### Leaflet 1.1
Creating interactive maps is crucial in developing data products. One widely used JavaScript library for this is Leaflet, which also has an associated R package that enables the creation of interactive maps in the R environment. Using Leaflet within RStudio is especially convenient as it opens up in the RStudio window. While there are other ways to create interactive maps, such as GoogleVis, Leaflet is popular among the R community. However, you may also want to explore creating maps using Google Maps in the GoogleVis lecture. To get started with Leaflet, you should first install the package by running the command install.packages("leaflet"). Let's now look at a code example that demonstrates how to create your first Leaflet map in R. The R Markdown document for the following slides contains two sections - one that displays the code and another that evaluates it. To create the map, first load the library by running library(leaflet), and then execute the three commands provided. You can then zoom in as much as you like on the resulting map. In order to develop data products, creating interactive maps is an important aspect. The Leaflet package for R makes use of the Leaflet JavaScript library to create such maps within the R environment, and is particularly convenient to use within RStudio. We will begin by exploring some Leaflet examples to get you started, and it won't take long for you to become familiar with it. While there are several other ways to create interactive maps, such as using GoogleVis, Leaflet is widely accepted and widely used within the R community. To get started, you need to install the package by running install.packages("leaflet"). The code for creating your first Leaflet map in R is shown in the R markdown document for the next few slides, and it includes piping notation which we will use heavily in these lectures. The first command, leaflet(), generates the map, while the addTiles() command adds the first set of content. We will discuss how to add more useful features, such as markers, later on. For now, try generating a world map and zooming around to ensure that you have successfully installed the Leaflet library.

### Leaflet 1.2
We were able to quickly generate a JavaScript map widget without any knowledge of JavaScript using the Leaflet function, which creates a background layer. The addTiles function adds mapping data from Open Street Map to the background. After adding this content, we can zoom in and explore the map. However, to add markers and direct interactivity, we need to use the addMarkers function, which is very easy to use. We can specify the longitude and latitude of a location and add a label to the marker. In the example, we added a marker for Johns Hopkins hospital with the label "Jeff Leek's office". The piping notation was used, and although it can be a little strange at first, it's a cleaner and easier way to read the code. We can click on the marker to see Jeff Leek's office and zoom in to see the Bloomberg School of Public Health. To recap, we were able to generate a map without knowing any JavaScript by using the leaflet function, which creates a background for the map. The addTiles function adds mapping data from OpenStreetMap to the background, and this allows us to zoom in and out and look around. However, to add specific content, like markers, we need to use additional functions. The addMarkers function is used to add markers to the map at specific longitude and latitude points, and we can also give them labels. 

Now, let's go through the code. To explain the piping notation, I will show you the equivalent code. First, let's reset my_map to its initial state with no markers. Then, to add the marker, we use the addMarkers function and pipe the output to my_map using the piping notation. This is equivalent to writing my_map = addMarkers(my_map, ...), and the code we used adds a marker at a specific location with a label. I will copy this code, as it is easier than retyping it. 

Additionally, it is worth noting that the Bloomberg School of Public Health is the oldest School of Public Health in the country. Okay, let's break down what's happening here. The lines of code that we just wrote to add a marker are equivalent to this one line of code. We're using the pipe operator to pass `my_map` as the first argument to the `addMarkers()` function. Then, we assign the result back to `my_map`.

Now, you might be wondering why we're doing all of this when we could have just kept the one-liner. Well, the reason is that piping is a powerful tool that you'll want to get used to, especially when you're doing chained operations in tools like `dplyr` or in mapping contexts like this. When you're adding lots of layers and markers, it can become tedious to keep retyping the same set of commands. The first line is only necessary because we separated it from the set of lines up above. Let me show you another way of writing this code, which is what you would likely do. Instead of using the piping operator, you would assign `my_map` to the initial map and then add the marker using `addMarkers()`. This set of commands is equivalent to the previous one. The reason why you might prefer the chaining approach is that it simplifies the code and avoids having to reassign the variable every time you add a new layer or marker. This is particularly useful when working with complex maps with lots of layers and markers. From now on, we will use the chaining approach to demonstrate Leaflet commands. 

To add a marker, you just need to provide the `addMarkers()` function with the `my_map` variable as the first argument, followed by the longitude and latitude coordinates, and the text for the popup. For example, in the code we just saw, the longitude and latitude coordinates are for Jeff Leek's office and the popup text says "Jeff Leek's office". If you have a map with many markers, you can use this function to add each one with its own set of coordinates and popup text. We will cover more examples in the following sections.


### Leaflet 1.3
To add a lot of markers, you can simply put the collection of markers in a data frame. Here's an example. First, let's set the seed so that we get the same results every time we run the code. Then, we'll create a data frame with some random longitude and latitudes. The data frame has 20 rows, and the columns are named "lat" and "lng". We'll pass this data frame as an argument to leaflet to create our map, which will initially be blank. If we run the code up to this point, we'll get a blank map. Next, we'll pass the output of the leaflet argument evaluated at the data frame to the addTiles function. This will add the mapping data to the map, but won't plot anything yet. Finally, we'll pass the map with the mapping data to the addMarkers function to add the markers. You can run the entire code at once instead of in pieces. The resulting map will have multiple markers. Give it a try by creating your own data frame with random longitude and latitudes and adding it to a map with markers.


### Leaflet 1.4
In the following code, we will cover two topics: adding custom markers and separate popups for each marker. We want to achieve this result, where each marker displays the Hopkins logo and has a separate popup. Here is an example of what we're aiming for. We'll first define our Hopkins icon by specifying its URL, width, height, and anchor points. Then we'll create a series of latitude and longitude values for buildings at Hopkins. We'll pass these values to leaflet, which will generate a map with markers using the addTiles and addMarkers functions. However, we also need to set the icon for each marker to the Hopkins icon. Once we have the markers displaying the Hopkins logo, we want to add links to each marker. We'll create a series of sites, which are text vectors containing HTML commands that create a hyperlink for each building. These sites correspond to the latitude and longitude values in the same order. Finally, we'll pass the latitude and longitude values to leaflet, addTiles, and addMarkers functions, along with the Hopkins icon. We'll set the popup to display the collection of hopkinsSites. Once we run the entire code, we will have a map with Hopkins logos at each marker, and separate popups with links for each building.

### Leaflet 1.5
Leaflet offers a great solution for situations when multiple points appear too close together to differentiate. This solution is clustering, where the points are grouped together and will break apart into individual points when the map is zoomed in. To demonstrate this feature, we can define a data frame with 500 latitude and longitude points that are close together and pass it as an argument to leaflet. Then, we can add tiles and markers with default cluster options. The clusters will show the number of points they contain. As we zoom in, the clusters break apart into individual points. Additionally, we can add circle markers instead of standard pop-ups or clusters by using the add circle markers command. We can create a couple of 20 markers and add circle markers to them. This will display the markers as little circles.


### Leaflet 1.6
Now, let's discuss how to digitally draw shapes on your map. This can be accomplished using commands that allow you to draw circles and rectangles, and even add a legend to your map. These commands will enable you to annotate and draw on your map in useful ways. We will demonstrate how to draw a circle in a way that you might actually want to use. For example, we have a dataset of cities such as Baltimore, Frederick, Rockville, and Gaithersburg, along with their population, latitude, and longitude. We will pass this dataset to leaflet, add tiles to it, and then add circles to it using the addCircles command. We will also provide some important options such as scaling the radius relative to the population of the cities. This is a more reasonable use of adding circles than just having them as markers. Let's go ahead and run the code to see the result. Alright, now we have the circles representing the population of the cities and we can see the relative sizes of the circles. Let's move on to drawing rectangles. We can use the addRectangles command to do that. Here's an example where we're going to draw a rectangle around Baltimore city. So we'll define a bounding box that contains Baltimore and then use that to draw the rectangle. Finally, we'll add a legend to the map to explain what the circles and the rectangle represent. So let's get started.

We'll define a bounding box that contains Baltimore using the leaflet boundingBox function. Then we'll pass that to the addRectangle function along with some options to define the color and opacity of the rectangle. Finally, we'll add a legend to the map using the addLegend function. This will display a key explaining what the circles and rectangle represent. So let's run the code and see the final map. Let's move on to adding a rectangle to the map to show you what it looks like. We'll use the same process as before, starting with leaflet, adding tiles, and then adding the rectangle. For a rectangle, you just need to provide the coordinates of its two opposite corners. In this example, we're creating a rectangle around the Mountain View Corporate Center. Next, let's cover how to add a legend to the map. This is a common task when you want to differentiate between different annotations, such as circles and rectangles, using different colors and symbols, and want to provide a key for users to understand what each one means. Here, we have a data frame containing 20 points. Let's try creating a rectangle to demonstrate how to add it to the map. First, we'll add tiles to the Leaflet map. Then, we'll add a rectangle using the coordinates of its two opposite corners. Here's the rectangle that we created, which happens to be the Mountain View Corporate Center. Finally, we'll cover how to add a legend. When you add markers to your map, you may want to color them differently and add a legend to help the user understand what each color represents. In this example, we have a data frame with 20 points, colored red, blue, or green. We pass the data frame to Leaflet and add circle markers colored according to the random color we generated. Of course, in a real application, you would want to use colors that have a specific meaning. To add a legend, we use the same syntax as the legend command in base R plotting. We define labels, in this case just LETTERS[1:3], and colors, which are blue, red, and green. When we run the code, the legend appears at the top of the map. This is the last lecture on Leaflet. We hope you found it useful. Leaflet is a powerful tool, and when used in conjunction with Shiny, it can create amazing applications. It's also one of the easiest interactive plotting utilities available in R, and definitely worth learning. Thanks for joining us, and we look forward to seeing you in the next lab.


## Quiz 

## Assignment